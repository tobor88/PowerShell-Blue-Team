#Requires -Version 3.0
Function Remove-RansomwareNote {
<#
.SYNOPSIS
This script utilizes  the SMB port 445 to map the C drive of remote devices, discover and delete a ransomware note by its file name


.DESCRIPTION
Delete ransomware notes saved on devices that have the same filename for the file by mapping the remote drive and searching for the file by is file name


.PARAMETER ComputerName
List of devices to map the remote drive of and remove ransomware notes off of

.PARAMETER FileName
Name of the ransomware file note to filter for

.PARAMETER Credential
Specifies a user account that has permission to do this action. The default is the current user.

Since PowerShell 3.0, when the value of the Root parameter is a UNC path, you can use credentials to create file system drives.

Type a user name, such as User01 or Domain01\User01 , or enter a PSCredential object generated by the `Get-Credential` cmdlet. If you type a user name, you're prompted to enter the password.

Credentials are stored in a PSCredential (/dotnet/api/system.management.automation.pscredential)object and the password is stored as a SecureString (/dotnet/api/system.security.securestring).

> [!NOTE] > For more information about SecureString data protection, see > How secure is SecureString? (/dotnet/api/system.security.securestring#how-secure-is-securestring).


.EXAMPLE
Remove-RansomwareNote -ComputerName $ComputerName -FileName "Ransom.txt" -Credential (Get-Credential -Message "Enter your credentials to map the C drive of remote devices")
# This example finds all files named 'Ransom.txt' all computers in the $ComputerName value and deletes them 

.EXAMPLE
Remove-RansomwareNote -ComputerName "dc01.domain.com","dhcp.domain.com","files.domain.com" -FileName "Ransom.txt" -Credential (Get-Credential -Message "Enter your credentials to map the C drive of remote devices")
# This example finds all files named 'Ransom.txt' from servers dc01, dhcp, and files in domain.com and deletes them 


.NOTES
Author: Robert Osborne
Alias: tobor
Contact: info@osbornepro.com


.LINK
https://osbornepro.com
https://encrypit.osbornepro.com
https://writeups.osbornepro.com
https://btpssecpack.osbornepro.com
https://github.com/tobor88
https://github.com/OsbornePro
https://gitlab.com/tobor88
https://www.powershellgallery.com/profiles/tobor
https://www.linkedin.com/in/roberthosborne/
https://www.credly.com/users/roberthosborne/badges
https://www.hackthebox.eu/profile/52286


.INPUTS
System.String[]


.OUTPUTS
System.Management.Automation.PSObject
#>
[OutputType([System.Management.Automation.PSObject])]
[CmdletBinding()]
    param(
        [Parameter(
            Position=0,
            Mandatory=$True,
            ValueFromPipeline=$True,
            ValueFromPipelineByPropertyName=$False,
            HelpMessage="[H] Enter a list of FQDNs, hostnames, or IP addresses of devices you wish to remotely delete the ransomware note from `n[?] Computer Names "
        )]  # End Parameter
        [String[]]$ComputerName,

        [Parameter(
            Position=1,
            Mandatory=$True,
            ValueFromPipeline=$False,
            HelpMessage="[H] Enter the name of the ransomware note file to find and delete `n[E] EXAMPLE: RansomwareNote.txt `n[?] File Name "
        )]  # End Parameter
        [SupportsWildcards()]
        [ValidateScript({$_ -notlike "\" -and $_ -notlike "/"})]
        [String]$FileName,

        [Parameter(
            ParameterSetName="Credential",
            Position=2,
            Mandatory=$True,
            ValueFromPipeline=$False
        )]  # End Parameter
        [ValidateNotNull()]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]
        $Credential = [System.Management.Automation.PSCredential]::Empty
    )  # End param

BEGIN {

    $Results = @()

} PROCESS {
    
    ForEach ($C in $ComputerName) {

        Try {

            Write-Verbose -Message "[v] Mapping temporary drive"
            New-PSDrive -Name Temp -PSProvider FileSystem -Root "\\$C\C$\" -Description "Temp drive mapped to delete files" -Credential $Credential -ErrorAction Stop | Out-Null


            Write-Verbose -Message "[v] Discovering files named $FileName on $C"
            $Path = (Get-ChildItem -Path "C:\" -Recurse -Filter $FileName -Force -ErrorAction SilentlyContinue).FullName

            If (Test-Path -Path $Path) {

                Write-Verbose -Message "[v] Deleting the discovered files by the name $FileName"
                Remove-Item -Path $Path -Force -Confirm:$False


                Write-Debug -Message "[v] Adding SUCCESS result for $C"
                $Results += New-Object -TypeName PSCustomObject -Property @{
                    ComputerName=$C;
                    DriveMapped=$True;
                    FilesDeleted=$(Test-Path -Path $Path)
                }  # End New-Object -Property

            } Else {

                Write-Debug -Message "[v] Adding SUCCESS result for $C"
                $Results += New-Object -TypeName PSCustomObject -Property @{
                    ComputerName=$C;
                    DriveMapped=$True;
                    FilesDeleted="No files found using name filter: $FileName"
                }  # End New-Object -Property

            }  # End If Else

        } Catch {

            Write-Debug -Message "[v] Adding FAILURE result for $C"
            $Results += New-Object -TypeName PSCustomObject -Property @{
                ComputerName=$C;
                DriveMapped=$False;
                FilesDeleted=$False;
            }  # End New-Object -Property

        } Finally {
    
            Remove-PSDrive -Name Temp -PSProvider FileSystem -Force -Confirm:$False -ErrorAction SilentlyContinue | Out-Null

        }  # End Try Catch Finally

    }  # End ForEach

} END {

    Return $Results

}  # End B P E

}  # End Function Remove-RansomwareNote
